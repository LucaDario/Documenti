\newpage

\section{Metriche}

\subsection{Metriche per i documenti}
Per i documenti redatti si è scelto di utilizzare l'indice di leggibilità per la lingua italiana: l'indice di Gulpease.

\subsubsection{L'indice di Gulpease}
L'indice Gulpease rispetto ad altri indici di leggibilità possiede il vantaggio di utilizzare la lunghezza delle parole in lettere anziché in sillabe, semplificando il calcolo dell'indice stesso. Esso considera due variabili linguistiche:
\begin{itemize}
\item La lunghezza della parola;
\item La lunghezza della frase rispetto al numero delle lettere.
\end{itemize}

I valori dell'indice sono compresi tra 0 e 100, dove il valore 100 indica la leggibilità più alta e 0 la leggibilità più bassa.
Gli intervalli richiesti per ogni documento redatto sono i seguenti:
\begin{itemize}
\item Accettazione: [40 -- 100];
\item Ottimale: [50 -- 100].
\end{itemize}

\subsection{Metriche per il software}

Questa sezione, che verrà rivista e incrementata nelle prossime revisioni, è da intendere come una dichiarazione di propositi.
Per raggiungere gli obiettivi auspicati dallo standard ISO di riferimento (ISO/IEC 9126), ovvero funzionalità, affidabilità,
efficienza, usabilità e manutenibilità, saranno applicate le seguenti metriche:

\subsubsection{Numero di livelli di annidamento per metodo}
Rappresenta il numero di strutture di controllo, annidate tra loro, internamente ad un metodo.
Un valore elevato per questa metrica potrebbe essere indice di una complessità troppo elevate del metodo stesso, e di un basso livello di astrazione del codice.
Intervalli richiesti:
\begin{itemize}
\item
Accettazione: [1 -- 5];
\item
Ottimale: [1 −- 3].
\end{itemize}

\subsubsection{Complessità ciclomatica}
Questo indice viene utilizzato per misurare la complessità di un programma. Esso misura direttamente il numero di cammini linearmente indipendenti attraverso il \termine{grafo di controllo di flusso}. I nodi del grafo corrispondono a gruppi indivisibili di istruzioni, mentre gli archi connettono due nodi se il secondo gruppo di istruzioni può essere eseguito immediatamente dopo il primo gruppo.
Alti valori di \termine{complessità ciclomatica} implicano una ridotta manutenibilità del codice. Valori bassi potrebbero però determinare  una scarsa efficienza dei metodi. McCabe, ideatore di questa metrica, raccomandava che i programmatori contassero la complessità dei moduli in sviluppo, e li dividessero in moduli più piccoli, qualora tale complessità superi 10 ma osservando che in certe circostanze può essere appropriato rilassare tale restrizione e permettere moduli con una complessità anche di 15.
Intervalli richiesti:
\begin{itemize}
\item
Accettazione: [1 -− 15];
\item
Ottimale: [1 -− 10].
\end{itemize}

\subsubsection{Numero di attributi per classe}
Questa metrica prevede di valutare la qualità del software in base al numero di attributi presenti in una classe.
Un numero elevato di attributi potrebbe evidenziare un possibile errore di progettazione con conseguente necessità di suddividere la classe in più classi in relazione tra loro seguendo il principio dell'incapsulamento.
Intervalli richiesti:
\begin{itemize}
\item
Accettazione: [0 −- 12];
\item
Ottimale: [0 −- 8].
\end{itemize}

\paragraph{Copertura dei test}
Questo indice indica la percentuale di istruzioni del prodotto che vengono eseguite durante i test.
Un valore percentuale alto indica una maggiore copertura dei test e quindi una maggiore probabilità che le componenti abbiano una ridotta quantità di errori.
Tale indice può però essere abbassato da metodi molto semplici che non richiedono testing come ad esempio metodi \texttt{getter} e/o \texttt{setter}.
Intervalli richiesti:
\begin{itemize}
\item
Accettazione: [40\% −- 100\%];
\item
Ottimale: [65\% −- 100\%].
\end{itemize}

\paragraph{Linee di commento per linee di codice}
Questo indice indica il rapporto tra linee di commento e linee di codice ed è utile per stimare la manutenibilità e la comprensibilità del codice. 
Intervalli richiesti:
\begin{itemize}
\item
Accettazione: [> 0.15];
\item
Ottimale: [>0.20].
\end{itemize}

\subsection{Metriche per la progettazione}

\subsubsection{Numero di parametri per metodo}
Rappresenta il numero di parametri da passare per la chiamata di un metodo.
Un numero elevato per un dato metodo potrebbe evidenziare la necessità di ridurne le funzionalità associate e/o suddividerle in altri metodi ausiliari.
Un alto valore di questo indice potrebbe evidenziare pertanto un possibile errore di progettazione.
Intervalli richiesti:
\begin{itemize}
\item
Accettazione: [0 −- 6];
\item
Ottimale: [0 −- 4].
\end{itemize}

\subsubsection{Livello di stabilità}
Per comprendere questa metrica è necessario dare una semplice spiegazione di \termine{accoppiamento afferente} e di \termine{accoppiamento efferente}.
\begin{itemize}
\item
\textbf{Accoppiamento afferente}: indica il numero di classi esterne ad un \termine{package} che dipendono da classi interne ad esso.
Un alto valore implica un alto grado di dipendenza del resto del software dal \termine{package}. Un valore eccessivamente basso, invece, potrebbe evidenziare che un \termine{package} fornisce poche funzionalità.
\item
\textbf{Accoppiamento efferente}: indica il numero di classi interne al \termine{package} che dipendono da classi esterne ad esso.
Mantenendo il valore di tale indice basso è possibile garantire funzionalità di base indipendentemente dal resto del sistema.
\end{itemize}

La stabilità di un \termine{package} indica la possibilità di effettuare modifiche a tale \termine{package} senza influenzarne altri all'interno dell'applicazione. Tale indice è strettamente legato all'accoppiamento efferente ed afferente e viene calcolato dalla seguente formula:

\begin{displaymath}
{\text{Accoppiamento Afferente}}\over{\text{Accoppiamento Afferente} + \text{Accoppiamento Efferente}}
\end{displaymath}

Intervalli richiesti:
\begin{itemize}
\item
Accettazione: [0.0 −- 0.8];
\item
Ottimale: [0.0 −- 0.3].
\end{itemize}

\subsection{Funzionalità}
Rappresenta la capacità del prodotto di fornire tutte le funzioni che sono state individuate attraverso l'\AdR.

\subsubsection{Obiettivi di qualità}
Il \termine{team} si impegnerà affinché:
\begin{itemize}
\item \textbf{Adeguatezza}: le funzionalità fornite siano conformi rispetto le aspettative;
\item \textbf{Accuratezza}: il prodotto fornisca i risultati attesi, con il livello di dettaglio richiesto;
\item \textbf{Sicurezza}: il prodotto protegga le informazioni e i dati da accessi e modifiche non autorizzati.
\end{itemize}

\subsubsection{Metriche}
\paragraph{Completezza dell'implementazione funzionale}
Indica la percentuale di requisiti funzionali coperti dall'implementazione.
\begin{itemize}
	\item \textbf{Misurazione}: 
		$$C=\left(1-\mathlarger{\frac{N_{FM}}{N_{FI}}}\right) \cdot 100$$ 
	dove $N_{FM}$ è il numero di funzionalità mancanti nell'implementazione e $N_{FI}$ è il numero di funzionalità individuate nell'attività di analisi.
	\item \textbf{Range ottimale}: 100.
	\item \textbf{Range di accettazione}: 100.
\end{itemize}

\paragraph{Accuratezza rispetto alle attese}
Indica la percentuale di risultati concordi alle attese.
\begin{itemize}
	\item \textbf{Misurazione}: 
		$$A=\left(1-\mathlarger{\frac{N_{RD}}{N_{TE}}}\right) \cdot 100$$
	dove $N_{RD}$ è il numero di test che producono risultati discordanti rispetto alle attese e $N_{TE}$ è il numero di test-case eseguiti.
	\item \textbf{Range ottimale}: 100.
	\item \textbf{Range di accettazione}: 90 -- 100.
\end{itemize}

\paragraph{Controllo degli accessi}
Indica la percentuale di operazioni illegali non bloccate.
\begin{itemize}
	\item \textbf{Misurazione}: 
		$$I=\mathlarger{\frac{N_{IE}}{N_{II}}} \cdot 100$$
	dove $N_{IE}$ è il numero di operazioni illegali effettuabili dai test e $N_{II}$ è il numero di operazioni illegali individuate.
	\item \textbf{Range ottimale}: 0.
	\item \textbf{Range di accettazione}: 0 -- 10.
\end{itemize}


\subsection{Affidabilità}
Rappresenta la capacità del prodotto software di svolgere correttamente le sue funzioni durante il suo utilizzo, anche nel caso in cui si presentino situazioni anomale.

\subsubsection{Obiettivi di qualità}
L'esecuzione del prodotto dovrà presentare le seguenti caratteristiche:
\begin{itemize}
\item \textbf{Maturità}: dovrà essere evitato che si verifichino malfunzionamenti, operazioni illegali e restituzione di risultati errati (\textit{failure}) in seguito a difetti;
\item \textbf{Tolleranza agli errori}: nel caso in cui si presentino degli errori, dovuti a guasti o ad un uso scorretto dell'applicativo, questi dovranno essere gestiti in modo da mantenere alto il livello di prestazione.
\end{itemize}

\subsubsection{Metriche}
\paragraph{Densità di \textit{failure}}
Indica la percentuale di operazioni di testing che si sono concluse in fallimenti.

\begin{itemize}
	\item \textbf{Misurazione}: 
		$$F=\mathlarger{\frac{N_{FR}}{N_{TE}}} \cdot 100$$
	dove $N_{FR}$ è il numero di fallimenti rilevati durante l'attività di testing e $N_{TE}$ è il numero di test-case eseguiti.
	\item \textbf{Range ottimale}: 0.
	\item \textbf{Range di accettazione}: 0 -- 10.
\end{itemize}

\paragraph{Blocco di operazioni non corrette}
Indica la percentuale di funzionalità in grado di gestire correttamente i \textit{fault} che potrebbero verificarsi.
\begin{itemize}
	\item \textbf{Misurazione}: 
		$$B=\mathlarger{\frac{N_{FE}}{N_{ON}}} \cdot 100$$
	dove $N_{FE}$ è il numero di \textit{failure} evitati durante i test effettuati e $N_{ON}$ è il numero di test-case eseguiti che prevedono l'esecuzione di operazioni non corrette, causa di possibili \textit{failure}.
	\item \textbf{Range ottimale}: 100.
	\item \textbf{Range di accettazione}: 80 -- 100.
\end{itemize}

\subsection{Usabilità}
Rappresenta la capacità del prodotto di essere facilmente comprensibile e attraente in ogni sua parte per qualsiasi utente che lo andrà ad utilizzare.

\subsubsection{Obiettivi di qualità}
Il prodotto dovrà puntare ai seguenti obiettivi di usabilità:
\begin{itemize}
\item \textbf{Comprensibilità)}: l'utente dovrà essere in grado di riconoscerne le funzionalità offerte dal software e dovrà comprenderne le modalità di utilizzo per riuscire a raggiungere i risultati attesi;
\item \textbf{Apprendibilità}: dovrà essere data la possibilità all'utente di imparare ad utilizzare l'applicazione senza troppo impegno;
\item \textbf{Operabilità}: le funzionalità presenti dovranno essere coerenti con le aspettative dell'utente.
\end{itemize}

\subsubsection{Metriche}
\paragraph{Comprensibilità delle funzioni offerte}
Indica la percentuale di operazioni comprese in modo immediato dall'utente, senza la consultazione del manuale.
\begin{itemize}
	\item \textbf{Misurazione}: 
		$$C=\mathlarger{\frac{N_{FC}}{N_{FO}}} \cdot 100$$
	dove $N_{FC}$ è il numero di funzionalità comprese in modo immediato dall'utente durante l'attività di testing del prodotto e $N_{FO}$ è il numero di funzionalità offerte dal sistema.
	\item \textbf{Range ottimale}: 90 -- 100.
	\item \textbf{Range di accettazione}: 80 -- 100.
\end{itemize}

\paragraph{Facilità di apprendimento delle funzionalità}
Indica il tempo medio impiegato dall'utente nell'imparare ad usare correttamente una data funzionalità.
\begin{itemize}
	\item \textbf{Misurazione}: indicatore numerico, espresso in minuti, che tiene traccia del tempo medio impiegato dall'utente nell'apprendere il corretto utilizzo di una funzionalità offerta dal sistema.
	\item \textbf{Range ottimale}: 0 -- 15.
	\item \textbf{Range di accettazione}: 0 -- 30.
\end{itemize}

\paragraph{Consistenza operazionale in uso}
Indica la percentuale di messaggi e funzionalità offerte all'utente che rispettano le sue aspettative riguardo al comportamento del software.
\begin{itemize}
	\item \textbf{Misurazione}: 
		$$C=\left(1-\mathlarger{\frac{N_{MFI}}{N_{MFO}}}\right) \cdot 100$$
	dove $N_{MFI}$ è il numero di messaggi e funzionalità che non rispettano le aspettative dell'utente e $N_{MFO}$ è il numero di messaggi e funzionalità offerti dal sistema.
	\item \textbf{Range ottimale}: 90 -- 100.
	\item \textbf{Range di accettazione}: 80 -- 100.
\end{itemize}

\subsection{Efficienza}
\label{efficienza}
Rappresenta la capacità di eseguire le funzionalità offerte dal software nel minor tempo possibile utilizzando al tempo stesso il minor numero di risorse possibili.

\subsubsection{Obiettivi di qualità}
Il prodotto dovrà essere efficiente, in particolare:
\begin{itemize}
\item \textbf{Comportamento rispetto al tempo}:  per svolgere le sue funzioni il software dovrà fornire adeguati tempi di risposta ed elaborazione;
\item \textbf{Utilizzo delle risorse}: il software quando eseguirà le sue funzionalità dovrà utilizzare un appropriato numero e tipo di risorse.
\end{itemize}

\subsubsection{Metriche}
\paragraph{Tempo di risposta}
Indica il periodo temporale medio che intercorre fra la richiesta al software di una determinata funzionalità e la restituzione del risultato all'utente.
\begin{itemize}
	\item \textbf{Misurazione}: 
		$$T_{RISP} = \mathlarger{\frac{\sum_{i=1}^{n} T_{i}}{n}}$$ 
	con $T_{RISP}$ misurato in secondi, e dove $T_{i}$ è il tempo intercorso fra la richiesta $i$ di una funzionalità ed il completamento delle operazioni necessarie a restituire un risultato a tale richiesta.
	\item \textbf{Range ottimale}: 0 -- 3.
	\item \textbf{Range di accettazione}: 0 -- 8.
\end{itemize}

\subsection{Manutenibilità}
Rappresenta la capacità del prodotto di essere modificato, tramite correzioni, miglioramenti o adattamenti del software a cambiamenti negli ambienti, nei requisiti e nelle specifiche funzionali.

\subsubsection{Obiettivi di qualità}
Le operazioni di manutenzione andranno agevolate il più possibile adottando le seguenti caratteristiche:
\begin{itemize}
\item \textbf{Analizzabilità}: il software dovrà consentire una rapida identificazione delle possibili cause di errori e malfunzionamenti;
\item \textbf{Modificabilità}: il prodotto originale dovrà permettere eventuali cambiamenti in alcune sue parti;
\item \textbf{Stabilità}: non dovranno insorgere effetti indesiderati in seguito a modifiche effettuate sul software;
\item \textbf{Testabilità}: il software dovrà poter essere facilmente testato per validare le modifiche effettuate.
\end{itemize}

\subsubsection{Metriche}
\paragraph{Capacità di analisi di \textit{failure}}
Indica la percentuale di \textit{failure} registrate delle quali sono state individuate le cause.
\begin{itemize}
	\item \textbf{Misurazione}: 
		$$I=\mathlarger{\frac{N_{FI}}{N_{FR}}} \cdot 100$$
	dove $N_{FI}$ è il numero di \textit{failure} delle quali sono state individuate le cause e $N_{FR}$ è il numero di \textit{failure} rilevate.
	\item \textbf{Range ottimale}: 80 -- 100.
	\item \textbf{Range di accettazione}: 60 -- 100.
\end{itemize}

\paragraph{Impatto delle modifiche}
Indica la percentuale di modifiche effettuate in risposta a \textit{failure} che hanno portato all'introduzione di nuove \textit{failure} in altre componenti del sistema.
\begin{itemize}
	\item \textbf{Misurazione}: 
		$$I=\mathlarger{\frac{N_{FRF}}{N_{FR}}} \cdot 100$$
	dove $N_{FRF}$ è il numero di \textit{failure} risolte con l'introduzione di nuove \textit{failure} e $N_{FR}$ è il numero di \textit{failure} risolte;
	\item \textbf{Range ottimale}: 0 -- 10.
	\item \textbf{Range di accettazione}: 0 -- 20.
\end{itemize}

\newpage