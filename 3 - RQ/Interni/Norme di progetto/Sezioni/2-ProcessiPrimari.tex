\section{Processi primari}
\subsection{Processo di fornitura}
In questa sezione verrà spiegato il processo di fornitura da parte del gruppo \gruppo.

\subsubsection{Studio di Fattibilità}
Alla pubblicazione dei capitolati d'appalto il \textit{\Pm} avrà il compito fissare un
numero sufficiente di riunioni volte alla discussione e al confronto tra i membri del \termine{team}.
In seguito, gli \textit{\AnP} dovranno stilare lo \textit{\SdF} in base a quanto
emerso nelle riunioni. Tale documento sarà articolato nei seguenti punti:
\begin{itemize}
	\item \textbf{Descrizione:} descrizione generale di ciò che viene richiesto
	dal capitolato.
	\item \textbf{Dominio Applicativo:} descrizione dell'ambito di utilizzo del
	prodotto richiesto e delle caratteristiche che deve avere il prodotto finale.
	\item \textbf{Dominio Tecnologico:} descrizione delle tecnologie impiegate
	nello sviluppo del progetto richiesto.
	\item \textbf{Potenziali Criticità:} elenco delle possibili problematiche che potrebbero
	sorgere durante lo sviluppo del prodotto richiesto, individuando quindi punti
	critici ed eventuali rischi.
	\item \textbf{Analisi di mercato} descrizione delle potenzialità del dominio applicativo.
	\item \textbf{Valutazione Finale:} piccolo elenco dei lati positivi e negativi del capitolato scelto.
\end{itemize}

\subsubsection{Pianificazione}
Per garantire una buona probabilità di successo del capitolato è stato redatto il documento \PdP\ contente la pianificazione dei periodi, la scelta del modello di vita del software e le \termine{milestones} per la consegna. \\
Infine per garantire qualità ai processi e al prodotto è stato redatto il documento \PdQ.

\paragraph{Strumenti}

\subparagraph{GanttChart}
Lo strumento per la costruzione dei diagrammi di Gantt contenuti nel \PdP\ che abbiamo scelto è \termine{GanttChart}.
Le ragioni che ci hanno portato a questa scelta sono:

\begin{itemize}
\item Facilità di utilizzo.
\item Problematiche legate all'estrapolazione del \termine{diagramma di Gantt} da \termine{Wrike}.
\end{itemize}

\subsubsection{Esecuzione e Controllo}
E' compito dei membri del gruppo eseguire i processi descritti in questo documento e monitorare continuamente il loro stato. Questa attività è necessaria anche per l'individuazione, registrazione, analisi e risoluzione dei problemi che potrebbero verificarsi.

\subsubsection{Revisione e Valutazione}
Questa attività è destinata ai \Ver\ che hanno il compito di attuare le attività di verificazione e validazione rispettivamente per i processi e per il prodotto. Una volta ottenuti i risultati, tramite essi, si deve valutare lo stato dei processi. Nel caso qualcuno di essi non superi la verifica, il gruppo \gruppo\ dovrà discutere su come intervenire per migliorare quel processo.

\subsection{Processo di sviluppo}
\subsubsection{Analisi dei Requisiti}
Ultimato lo \textit{\SdF} gli \textit{\AnP} dovranno stilare l'\textit{\AdR} che dovrà 	essere strutturata nel seguente modo.
\paragraph{Classificazione dei requisiti}
Dovrà essere stilato un elenco di requisiti, emersi durante le riunioni interne
e/o esterne. Questo compito spetta agli \textit{\AnP}. I requisiti dovranno
essere classificati secondo la seguente codifica:

\begin{center}
R-[Importanza][Tipo][Identificativo]
\end{center}
\begin{itemize}
	\item \textbf{Importanza:} può assumere questi valori:
  		\begin{itemize}
    		\item \textbf{1:} indica un requisito obbligatorio.
    		\item \textbf{2:} indica un requisito desiderabile.
    		\item \textbf{3:} indica un requisito facoltativo.
  		\end{itemize}
  	\item \textbf{Tipo:} può assumere questi valori:
  		\begin{itemize}
   		 	\item \textbf{F:} indica un requisito funzionale.
    		\item \textbf{Q:} indica un requisito di qualità.
    		\item \textbf{P:} indica un requisito prestazionale.
    		\item \textbf{V:} indica un requisito di vincolo.
  		\end{itemize}
  	\item \textbf{Identificativo:} indica il codice identificativo del requisito, è univoco e deve essere indicato in forma gerarchica.
\end{itemize}
Per ogni requisito si dovranno inoltre indicare:
\begin{itemize}
  \item \textbf{Descrizione:} una breve descrizione del requisito, che chiarisca tutti i punti di esso senza lasciare spazio a possibili ambiguità.
  \item \textbf{Fonte:} la fonte può essere una delle seguenti:
  \begin{itemize}
    \item \textit{\termine{Capitolato}}: deriva direttamente dal testo del capitolato.
    \item \textit{Verbale}: deriva da un incontro verbalizzato, seguito dall'identificativo dell'incontro.
    \item \textit{Interno}: deriva da discussioni interne al \termine{team}.
    \item \textit{Caso d'uso}: deriva da uno o più casi d'uso, seguito dall'identificativo del caso o dei casi d'uso.
  \end{itemize}
\end{itemize}

\paragraph{Classificazione dei casi d'uso}
Ogni requisito sarà specificato da un diagramma di caso d'uso e sarà rappresentato in questo modo:
\begin{center}
  UC[Identificativo]
\end{center}
dove:
\begin{itemize}
  \item\textbf{Identificativo}: è il codice gerarchico univoco, rappresentato in numeri, per identificare ogni caso d'uso.
\end{itemize}
Inoltre per ogni caso d'uso dovranno essere indicati:
\begin{itemize}
  \item\textbf{Titolo}: indica il titolo del caso d'uso.
  \item\textbf{Descrizione}: breve descrizione del caso d'uso.
  \item\textbf{Attori}: indica gli attori, sia principali che secondari, coinvolti nel caso d'uso.
  \item\textbf{Precondizione}: indica la condizione che deve essere verificata prima
  dell'esecuzione del caso d'uso.
   \item\textbf{Precondizione}: indica la condizione che deve essere verificata dopo dell'esecuzione del caso d'uso.
  \item\textbf{Scenario principale}: descrizione composta dal flusso dei casi d'uso
  figli.
  \item\textbf{Scenari alternativi}: descrizione composta dai casi d'uso che non
  appartengono al flusso principale di esecuzione.
  \item\textbf{Estensioni}: indica quali sono tutte le estensioni, se presenti.
  \item\textbf{Inclusioni}: indica quali sono tutte le inclusioni, se presenti.
  \item\textbf{Generalizzazioni}: indica quali sono tutte le generalizzazioni,
  se presenti.
  \item\textbf{Postcondizione}: indica la condizione che deve essere verificata dopo
  l'esecuzione del caso d'uso.
\end{itemize}

\paragraph{Obiettivi dell'analisi}

\begin{itemize}
\item Individuare tutti i requisiti tramite riunioni interne, tra i membri del gruppo, o esterne, con i committenti.
\item Ogni requisito deve essere concordato da tutti i membri.
\end{itemize}

\paragraph{Strumenti}

\subparagraph{Astah}
Lo strumento per la costruzione degli use cases che abbiamo scelto è \termine{Astah}.
Le ragioni che ci hanno portato a questa scelta sono:
\begin{itemize}
\item Disponibilità dello strumento di costruire \termine{Diagrammi dei casi d'uso}.
\item Possibilità di avere la licenza in modo gratuito essendo studenti.
\end{itemize}



\subsubsection{Progettazione}

\paragraph{Requisiti per i progettisti}
I \textit{\ProgP} sono responsabili delle attività di progettazione e sono tenuti ad avere:
\begin{itemize}
\item
Profonda conoscenza di tutto ciò che riguarda il processo di sviluppo del software.
\item
Capacità di saper anticipare i cambiamenti.
\item
Notevole inventiva per riuscire a trovare una soluzione progettuale accettabile anche in mancanza di una metodologia che sia sufficientemente espressiva.
\item
Capacità di individuare con rapidità e sicurezza le soluzioni più opportune.
\end{itemize}

L'attività di Progettazione coinvolge due attività, le quali:
\begin{itemize}
\item \textbf{Progettazione architetturale}
\item \textbf{Progettazione in dettaglio}
\end{itemize}

\paragraph{Progettazione architetturale}
\subparagraph{Descrizione}
L'attività di progettazione architetturale descrive le attività per realizzare la struttura dell'architettura software ed è necessaria per dominare la complessità del prodotto. Tale attività deve soddisfare i requisiti delineati all'interno del documento \AdR{} e dovrà essere svolta in maniera ottimale dai \textit{progettisti}.

\subparagraph{Diagrammi}
La progettazione deve utilizzare le seguenti tipologie di diagrammi \termine{UML}:
\begin{itemize}
\item
\textbf{Diagrammi dei \textit{\termine{package}}}: illustrano i vari raggruppamenti di classi in una unità di livello più alto.
\end{itemize}

\subparagraph{Obiettivi della progettazione architetturale}
L'attività di progettazione si pone i seguenti obiettivi:
\begin{itemize}
\item Realizzare una struttura architetturale per l'applicativo  resistente alle modifiche, senza che l'intera struttura venga compromessa e/o nuovamente messa in discussione.
\item Progettare un software con le caratteristiche che sono state elencate e descritte nella fase di analisi dei requisiti.
\item Identificare i \termine{Design Patterns} più utili al fine di creare un'architettura coesa, con poco accoppiamento e con un'elevata riusabilità.
\item Individuare le interfacce necessarie all'interazione tra le componenti tra loro e con l'ambiente.
\item Perseguire una buona qualità per l'architettura.
\end{itemize}

\paragraph{Progettazione in dettaglio}

\subparagraph{Descrizione}
L'attività di Progettazione in dettaglio definisce le unità realizzative, ovvero i moduli che poi andranno a formare l'intero sistema. Tali moduli devono essere specificati in modo dettagliato e devono essere descritte le interazioni tra di essi.

\subparagraph{Diagrammi}
La progettazione deve utilizzare le seguenti tipologie di diagrammi \termine{UML}:
\begin{itemize}
\item
\textbf{Diagrammi di classe}: illustrano una collezione di elementi dichiarativi di un modello come classi e tipi, assieme ai loro contenuti e alle loro relazioni.
\item
\textbf{Diagrammi di attività (opzionali)}: illustrano il flusso di operazioni relativo ad un'attività e utilizzati soprattutto per descrivere la logica di un algoritmo.
\item
\textbf{Diagrammi di sequenza}: descrivono una determinata sequenza di azioni dove tutte le scelte sono già state effettuate. In tali diagrammi non compaiono pertanto scelte né flussi alternativi. Verranno descritti solo per le operazioni reputate interessanti, cioè con un alto tassi di utilizzo e con una adeguata complessità, in modo che risultino interessanti da descrivere.
\end{itemize}

\subparagraph{Obiettivi della progettazione in dettaglio}
La fase di progettazione si pone i seguenti obiettivi:
\begin{itemize}
\item Soddisfare i requisiti obbligatori fissati dal committente.
\item Avere una chiara idea delle parti(classi,metodi e e variabili) che si andranno successivamente a codificare nel periodo che va dal \RP\ alla \RQ
\item Descrivere in maniera appopriata e comprensibile a uno sviluppatore esterno i metodi,le variabili e le classi codificate. Come successivamente descritto.
\item Descrivere in dettaglio le interazioni tra le varie componenti utilizzando i \textit{Design Patterns} scelti durante l'attività di progettazione architetturale.
\item Seguendo quanto detto per la progettazione architetturale, anche quella in dettaglio deve perseguire gli obbiettivi di coesione, basso accoppiamento e riusabilità dei moduli.
\end{itemize}

\paragraph{Strumenti}

\subparagraph{Astah}
Lo strumento per la costruzione dell'architettura di sistema e dettaglio che abbiamo scelto è \termine{Astah}.
Le ragioni che ci hanno portato a questa scelta sono:
\begin{itemize}
\item Disponibilità dello strumento di costruire \termine{Diagrammi dei package} per la progettazione architetturale.
\item Disponibilità dello strumento di costruire \termine{Diagrammi delle classi}, \termine{Diagrammi di sequenza} e \termine{Diagrammi delle attività} per la progettazione in dettaglio.
\end{itemize}

\subsubsection{Codifica}
\paragraph{Descrizione}
La fase di codifica ha come obiettivo quello di passare, nel miglior modo possibile, dalla soluzione architetturale realizzata dai \textit{\ProgP} a quella finale eseguibile da un calcolatore.
In questa fase i responsabili della codifica sono i \textit{\ProgrP} e questi sono tenuti a seguire le seguenti \termine{best practice}, con lo scopo di produrre il prodotto designato nella fase di progettazione.

\paragraph{Formattazione}
Per semplificare il compito del \textit{\Progr} è fondamentale delineare uno standard di formattazione.
Esso coincide nei seguenti punti:

\begin{itemize}
\item Mantenere l'indentazione standard di \termine{IntelliJ IDEA} composta da quattro(4) spazi.

\item Inserire le parentesi di apertura in modo \termine{inline}.

\item Utilizzare spazi vuoti nel codice sorgente in modo da suddividere il file in paragrafi migliorandone lettura e comprensione.

\item Inserire sempre le parentesi di apertura e di chiusura di una istruzione condizionale anche quando è presente solo uno \termine{statement} all'interno del suo corpo. In tal modo verrà facilitata la comprensione e manutenzione del codice.

\item Suddividere logicamente il codice in diversi file.

\item Cercare di incapsulare più possibile il codice e non di creare funzioni e/o classi con una eccessiva quantità di codice.
\end{itemize}

\paragraph{Commenti}
All'interno del codice è fondamentale inserire una buona quantità di commenti al fine di facilitare la comprensione, sia ad un lettore esterno, sia allo stesso programmatore a distanza di tempo.
Di seguito sono suggeriti alcuni metodi di inserimento di commenti che saranno utilizzati dal gruppo:

\begin{itemize}
\item Cercare di inserire commenti di facile comprensione a tutti.

\item Commentare tutto ciò che non è immediato nel codice.

\item Evitare l'inserimento di commenti alla fine di una riga di codice ma preferire tale inserimento nella riga sovrastante ad essa.

\item Commentare sempre tutte le istruzioni condizionali se considerate non di facile comprensione.

\item Tenere sempre aggiornati i commenti relativi all'eventuale codice che si va a modificare, al fine di evitare problemi di inconsistenza con esso.

\item Evitare commenti superflui o umoristici in quanto in caso di \termine{commit} resteranno nella storia dello sviluppo del software.
\end{itemize}

\paragraph{Nomi}
Lo schema di denominazione è uno dei supporti più determinanti per la comprensione del codice.
Di seguito sono elencate le tecniche per raggiungere un buon utilizzo dei nomi.

\begin{itemize}
\item Seguire la pratica \termine{camel case} per la denominazione delle variabili locali.
\item Seguire la pratica \termine{PascalCase} per la denominazione delle classi.
\item Seguire la pratica UPPER\textunderscore CASE per la denominazioni delle variabili statiche costanti.
\item Utilizzare uno nome significativo per le variabili, le classi ed i metodi scritti, al fine di rendere superflua qualunque documentazione.
\item Evitare di utilizzare gli stessi nomi per elementi diversi.
\item Utilizzare nome composti da una sola lettera solamente per le variabili che identificano un indice all'interno di una istruzione ciclica.
\item Cercare di utilizzare nomi diverse per tutte le classi, anche se facenti parte di packages diversi.
\item Per le variabile private delle classi si usa la pratica \termine{camel case} precedute da un underscore 
\end{itemize}

\subsubsection{Documentazione dei file}
All'interno di un progetto \termine{open source} un'altra caratteristica di fondamentale importanza risulta essere la documentazione. \\
Di seguito vengono pertanto riportate alcune \termine{best practice} per stilare una documentazione di facile comprensione.

\begin{itemize}
\item Scrivere la documentazione in lingua inglese, in quanto il software dovrà poter essere letto anche da sviluppatori internazionali.
\item Elencare in modo preciso tutte le variabili(anche quelle opzionali) ed i loro significato nei rispettivi metodi.
\item Segnalare il tipo ed il significato del dato ritornato dai rispettivi metodi.
\item Documentare in modo preciso il contratto di tutti i metodi pubblici e protetti delle classi.
\end{itemize}
Inoltre i \textbf{file contenenti codice} dovranno essere avere un \textbf{intestazione introduttiva} contenente:

\begin{lstlisting}[language=JavaScript]
/** 
 *   Created by {USER} on {DATE}.
 *   Version {VERSION} - {VERSION_NOTES}
 */
\end{lstlisting}
Dove:
\begin{itemize}
\item \{USER\} identifica l'utente che ha creato quel file.
\item \{DATE\} identifica la data, in formato GG/MM/AAAA, nella quale è stato creato il file.
\item \{VERSION\} identifica la versione del file attuale, inizialmente sarà impostata di default a 1.0.0.
\item \{VERSION\_NOTES\} identifica le note relative alla attuale versione, che identificano cosa è cambiato per portare a quella data versione. Inizialmente sarà impostata a 1.0.0 .
Per quanto riguarda la storia di ogni modifica dei file, abbiamo deciso di tenerla tracciata tramite lo strumento \textit{Git} invece di tenere un tracciamento tramite commenti.
\end{itemize}



All'interno del file le \textbf{classi} dovranno contenere la seguente intestazione:

\begin{lstlisting}[language=JavaScript]
/**
 *  class Nome della classe
 *  brief Breve descrizione della classe
 */
\end{lstlisting}

Per quanto riguarda i file contenenti solo un'\textbf{unica classe} non è necessario inserire i commenti appena descritti aggiungendo il nome della classe, ma la \textbf{descrizione} della classe dovrà essere inclusa direttamente nell'intestazione introduttiva.
\\



I \textbf{costruttori} delle classi dovranno contenere la seguente intestazione:

\begin{lstlisting}[language=JavaScript]
/**
 *  {TYPE} constructor
 *  @param {PARAM} {{PARAM_TYPE}}: {PARAM_DESC} 
 */
\end{lstlisting}
Dove:
\begin{itemize}
\item \{TYPE\}: Indicare "Public" se il costruttore è pubblico. "Private" se privato.
\item \{PARAM\}: Identifica il nome di un parametro.
\item \{\{PARAM\_TYPE\}\}: Identifica il tipo di un parametro, può essere Number (numero), String (stringa) o Object (oggetto).
\item \{PARAM\_DESC\}: Breve descrizione del parametro.
\end{itemize}
Se non vi sono parametri non includere "@param" nell'intestazione.
\\



All'interno del file i \textbf{metodi} dovranno contenere la seguente intestazione:

\begin{lstlisting}[language=JavaScript]
/**
 * {TYPE}
 * {COMMENT}
 * @param {PARAM} {{PARAM_TYPE}}: {PARAM_DESC}
 * @return {{RETURN_TYPE}}: {RETURN_DESC} 
 */
\end{lstlisting}

Dove:
\begin{itemize}
\item \{TYPE\} identifica il tipo della funzione, può essere:
\begin {itemize}
\item @method: Identifica una funzione diversa da un costruttore.
\end{itemize}
\item \{COMMENT\}: Identifica una breve descrizione della funzionalità del metodo.
\item \{PARAM\}: Identifica il nome di un parametro.
\item \{\{PARAM\_TYPE\}\}: Identifica il tipo di un parametro, può essere Number (numero), String (stringa) o Object (oggetto).
\item \{PARAM\_DESC\}: Breve descrizione del parametro.
\item \{\{RETURN\_TYPE\}\}: Identifica il tipo ritornato dal metodo.
\item \{RETURN\_DESC\}: Descrizione del tipo di ritorno del metodo.
\end{itemize}
Il tipo e la descrizione del tipo di ritorno non sono necessari nel caso in cui il metodo non ritorni nulla. Stesso ragionamento vale per i parametri nel caso in cui quest'ultimo non ne possieda.
\\



Infine eventuali metodi \texttt{get} e \texttt{set} dovranno essere scritti nel seguente modo:
\begin{center}
\textit{get/setNomeAttributo}
\end{center}
dove NomeAttributo è il nome dell'attributo al quale si vuole fare i metodi \texttt{get} e \texttt{set}. In questa maniera non sono necessari ulteriori commenti ai metodi perché autoesplicativi.
\\



All'interno dei file gli \textbf{attributi di una classe} saranno descritte in questa maniera:

\begin{lstlisting}[language=JavaScript]
/**
 * {TYPE}
 * {DESCRIPTION}
 */ 
\end{lstlisting}

Dove:
\begin{itemize}
\item \{TYPE\}: Identifica il tipo di un attributo, può essere Number (numero), String (stringa) o Object (oggetto).
\item \{DESCRIPTION\}: Identifica una breve descrizione della variabile.
\end{itemize}


Per abilitare la creazione automatica di questo commento in ogni file è necessario, all'interno di IntelliJ IDEA, eseguire la seguente procedura:
Aprire le impostazioni, quindi recarsi in Editor > File and Code Templates (oppure  utilizzare la shortcut Ctrl + Shift + A), cercare File template
Nel tab File e selezionare JavaScript File
Incollare, nella parte di destra, il seguente spezzone:
\begin{lstlisting}
/**
 * Created by {USER} on {DATE}
 * Version {VERSION} - {VERSION_NOTES}
 */
\end{lstlisting}
Cliccare su Apply.
  
\subsubsection{Ricorsione}
La ricorsione va evitata il più possibile. Per ogni funzione ricorsiva sarà necessario valutare il costo in termini di occupazione della memoria e bisognerà associare ad esso una prova di correttezza.
Valutare la memoria occupata dalla funzione sarà obbligatorio in quanto le funzioni ricorsive possono facilmente non terminare occupando tutto lo stack della memoria andando quindi in \termine{stack overflow}.

\paragraph{Obiettivi della codifica}
La fase di codifica si pone i seguenti obiettivi:
\begin{itemize}
\item Realizzare la demo come progettata nel \DDP.
\item Trasformare in un linguaggio adatto tutte le funzioni e le classi con i loro relativi attributi 
\end{itemize}

\subsubsection{Strumenti}

\paragraph{IntelliJ IDEA}
L'ambiente di sviluppo integrato (\termine{IDE}) scelto per lo sviluppo e la manutenzione del progetto è \termine{IntelliJ IDEA}. Le ragioni che hanno portato a questa scelta sono le seguenti:
\begin{itemize}
\item Disponibilità di svariati \termine{plugin} per lo sviluppo, in particolare per \termine{Meteor.js}.
\item Buona conoscenza di questo strumento d parte di tutti i componenti del \termine{team} maturata durante il corso di laurea.
\item Possesso di una completa integrazione con i metodi di versionamento \termine{Git}.
\item Abilità di autocompletamento del codice \termine{JavaScript} scritto.
\item Possesso di un \termine{debugger} \termine{JavaScript}.
\end{itemize}

\subsubsection{Integrazione}
In questo periodo si cerca di integrare le varie parti del nostro applicativo e del nostro sdk in maniera che funzioni correttamente interfacciandosi in  correttamente tra di loro. Per fare questo abbiamo sviluppato degli appositi test che andremo successivamente ad elencare.
Questa attività deve essere svolta in maniera ottimale e precisa dai \textit{progettisti}, che dovranno avere una chiara idea del funzionamento delle parti che hanno sviluppato e una idea abbastanza precisa del funzionamento delle parti che gli altri .\textit{progettisti} hanno sviluppato. Una volta finita l'integrazione tra le varie componenti si procederà a verificare tramite dei test appositi il completo e corretto funzionamento di tutto l'applicativo e l'SDK

\paragraph{Requisiti per i progettisti}
I \textit{\ProgP} sono responsabili delle attività di integrazione e sono tenuti ad avere:
\begin{itemize}
\item
Profonda conoscenza di tutto quello che hanno sviluppato.
\item
Capacità di saper effettuare piccoli cambiamneti al loro codice per integrarlo al meglio nel ecosistema del intero progetto.
\item
Conoscere le parti sviluppate da altri per poterle integrare al meglio.
\item
Avere competenze necessarie per sviluppare le parti mancanti di software che permettono l'interazione tra le varie parti.
\item
Capacità di individuare con rapidità i bug e i requisiti non soddisfatti che l'applicativo finale comporta.
\end{itemize}

\paragraph{Obiettivi per l'integrazione}
Il periodo in cui si svolge l'integrazione pone i seguenti obiettivi:
\begin{itemize}
\item Avere un applicativo che unisce tutte le parti software sviluppate indipendentemente e non, dai vari progettisti.
\item Controllare, e nel caso correggere eventuali errori e bug apparsi durante l'integrazione
\end{itemize}

\subsubsection{Sistemi Operativi}
Ogni componente del team ha scelto di usare il proprio sistema operativo preferito. Sono, dunque, utilizzate attualmente tre diversi sistemi: MacOs,  ArchLinux e Windows 10. L'uso di sistemi diversi, però, non risulta essere un problema per il corretto funzionamento del software poiché la programmazione avviene principalmente lato server rendendo cosi ininfluente la scelta del sistema operativo del client.

\newpage 